"""
This module contains functions related to the implementation of the algorithm simulated annealing,
so that the best location of the drones for a certain scenario, which indicates the traffic generated by users, can be found.
"""
import math
import random
import time
import numpy as np
import utils
import settings
import data_preprocess
random.seed(time.time())

def valid_position(position, nrows, ncolumns):
    """
    Checks if a certain position can represent valid coordinates of a matrix.
    """
    if(position[0] < 0 or position[1] < 0):
        return False
    elif(position[0] >= nrows or position[1] >= ncolumns):
        return False
    else:
        return True

def adjacent_position(position, nrows, ncolumns):
    """
    Gives a randomly generated adjacent position.
    """
    new_position = random.randint(0, 3)

    while True:
        if(new_position % 4 == 0 and valid_position([position[0]+1, position[1]], nrows, ncolumns)):
            return [position[0]+1, position[1]]
        elif(new_position % 4 == 1 and valid_position([position[0]-1, position[1]], nrows, ncolumns)):
            return [position[0]-1, position[1]]
        elif(new_position % 4 == 2 and valid_position([position[0], position[1]+1], nrows, ncolumns)):
            return [position[0], position[1]+1]
        elif(new_position % 4 == 3 and valid_position([position[0], position[1]-1], nrows, ncolumns)):
            return [position[0], position[1]-1]
        new_position += 1

def adjacent_state(drones, nrows, ncolumns):
    """
    Gives a randomly generated adjacent state.
    Each state consists of the positions of the three drones.
    """
    new_drones = drones.copy()
    drone_index = random.randint(0, len(drones) - 1)
    new_drones[drone_index] = adjacent_position(drones[drone_index], nrows, ncolumns)
    return new_drones

def value(model_throughput, model_delay, model_pdr, scenario, topology):
    """
    Gives the value (quality) of a certain pair scenario + topology.
    """
    scenario_topologies_list = np.array([np.array([scenario, topology])])
    if settings.CHANNELS_LAST:
        scenario_topologies_list = np.array(data_preprocess.build_input_structure_channels_last(scenario_topologies_list))
    throughput_pred = model_throughput.predict(scenario_topologies_list)
    delay_pred = model_delay.predict(scenario_topologies_list)
    pdr_pred = model_pdr.predict(scenario_topologies_list)
    return settings.quality(throughput_pred[0][0], delay_pred[0][0], pdr_pred[0][0]), [throughput_pred[0][0], delay_pred[0][0], pdr_pred[0][0]]

def get_topology(drones, mean, std, nrows, ncolumns):
    """
    Computes a matrix topology given the locations of the drones 
    and the mean and standard deviation of the elements in the matrix
    """
    topology = np.zeros((nrows, ncolumns))
    for drone in drones:
        topology[int(drone[0])][int(drone[1])] = 1
    if settings.DISTANCE_ENCODING:
        topology = utils.sparse_to_distance(topology)
    if settings.NORMALIZE_DATA:
        topology = utils.normalize_matrix(topology, mean, std)
    return topology

def simulated_annealing(model_throughput, model_delay, model_pdr, scenario, drones):
    """
    Main function of the module that implements the simulated annealing by calling the other functions.

    Args:
        model_throughput: Model used to predict the value of the throughput in a certain network
        model_delay: Model used to predict the value of the delay in a certain network
        model_pdr: Model used to predict the value of the pdr in a certain network
        scenario: Matrix that represents the traffic generated by the users
        drones: initial location of the drones in the simulated annealing algorithm

    Returns:
        best_drones, best_value, best_variables: Where:
        best_drones is the the drones location which the algorithm found to have the best value,
        best_value is the highest value of a state searched by the algorithm and
        best_variables is  the throughput, delay and pdr generated by the state which has the best value.
    """
    mean, std = utils.stats_matrix(scenario)
    nrows = len(scenario)
    ncolumns = len(scenario[0])
    topology = get_topology(drones, mean, std, nrows, ncolumns)
    current_value, variables = value(model_throughput, model_delay, model_pdr, scenario, topology)
    best_drones = drones.copy()
    best_value = current_value
    best_variables = variables.copy()
    temperature = 10000 # Initial value of the temperature
    while(temperature > 0):
        print("Temperature: "+str(temperature))
        print("Drones Location: "+str(drones))
        print("Current State Value: "+str(current_value))
        print("Variables: "+str(variables))
        print("\n")
        new_drones = adjacent_state(drones, nrows, ncolumns)
        new_topology = get_topology(new_drones, mean, std, nrows, ncolumns)
        new_value, new_variables = value(model_throughput, model_delay, model_pdr, scenario, new_topology)
        diff = new_value - current_value
        if(diff >= 0): # If new value is higher then current value, the algorithm transitions automatically to the next state.
            topology = np.copy(new_topology)
            current_value = new_value
            drones = new_drones
            variables = new_variables
            if(current_value > best_value):
                best_value = current_value
                best_drones = drones.copy()
                best_variables = variables.copy()
        else: # Otherwise, it transitions to the next state with certain probability
            probability = math.exp(10000*diff/temperature) 
            random_float = random.random()
            if(random_float < probability):
                topology = np.copy(new_topology)
                current_value = new_value
                drones = new_drones
                variables = new_variables
                if(current_value > best_value):
                    best_value = current_value
                    best_drones = drones.copy()
                    best_variables = variables.copy()
        temperature -= 1

    return best_drones, best_value, best_variables


